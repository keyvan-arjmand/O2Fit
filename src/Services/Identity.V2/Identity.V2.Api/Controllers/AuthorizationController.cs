using Identity.V2.Application.Countries.V1.Queries.GetCountryById;
using Identity.V2.Application.Countries.V1.Queries.GetOldSystemCountryIdByCountryId;
using Identity.V2.Application.Users.V1.Queries.CheckUserExitsByUsernameAndAutoGeneratedPassword;
using static OpenIddict.Abstractions.OpenIddictConstants;
using SignInResult = Microsoft.AspNetCore.Identity.SignInResult;

namespace Identity.V2.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class AuthorizationController : BaseApiController
{
    private readonly SignInManager<User> _signInManager;
    private readonly UserManager<User> _userManager;
    private readonly IOpenIddictApplicationManager _applicationManager;
    private readonly IOpenIddictScopeManager _scopeManager;
    private readonly IUserService _userService;
    private readonly IRoleService _roleService;
    private readonly IOpenIddictAuthorizationManager _authorizationManager;
    private readonly IConfiguration _configuration;
    private readonly IMediator _mediator;

    public AuthorizationController(
        SignInManager<User> signInManager,
        UserManager<User> userManager, IOpenIddictApplicationManager applicationManager,
        IOpenIddictScopeManager scopeManager, IUserService userService, IRoleService roleService,
        IOpenIddictAuthorizationManager authorizationManager, IConfiguration configuration, IMediator mediator)
    {
        _signInManager = signInManager;
        _userManager = userManager;
        _applicationManager = applicationManager;
        _scopeManager = scopeManager;
        _userService = userService;
        _roleService = roleService;
        _authorizationManager = authorizationManager;
        _configuration = configuration;
        _mediator = mediator;
    }

    //[EnableRateLimiting(O2fitIdentityConstants.RateLimitPolicyName)]
    [AllowAnonymous]
    [HttpPost("~/connect/token")]
    [IgnoreAntiforgeryToken]
    [Produces("application/json")]
    public async Task<ActionResult> Exchange()
    {
        var request = HttpContext.GetOpenIddictServerRequest() ??
                      throw new InvalidOperationException("The OpenID Connect request cannot be retrieved.");
        if (request.IsPasswordGrantType())
        {
            AuthenticationProperties? properties;
            if (!string.IsNullOrEmpty(request.Username))
            {
                var user = await _userService.GetUserByUsernameAsync(request.Username);
                if (user == null)
                {
                    properties = new AuthenticationProperties(new Dictionary<string, string>
                    {
                        [OpenIddictServerAspNetCoreConstants.Properties.Error] =
                            Errors.InvalidGrant,
                        [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] =
                            "The username/password couple is invalid."
                    }!);
                    //new ApiResult("The username/password couple is invalid.",ApiResultStatusCode.Forbidden,false)
                    return Forbid(properties, OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                }

                // Validate the username/password parameters and ensure the account is not locked out.
                if (!string.IsNullOrEmpty(request.Password))
                {
                    var decryptedAutoGeneratedPassword = EncryptionAndDecryptionUtility.Encrypt(
                        request.Password,
                        _configuration["EncryptionKey"]!);
                    var isNormalUser = await _mediator.Send(
                        new CheckUserExitsByUsernameAndAutoGeneratedPasswordQuery(user.UserName,
                            decryptedAutoGeneratedPassword)).ConfigureAwait(false);
                    if (!isNormalUser)
                    {
                        var result =
                            await _signInManager.CheckPasswordSignInAsync(user, request.Password, true);
                        if (result.Succeeded)
                        {
                            if (user.IsBlocked)
                                return BadRequest(new ApiResult("User is blocked", ApiResultStatusCode.BadRequest, false));

                            var country = await _mediator
                                .Send(new GetCountryByIdQuery(user.CountryId.ToString()))
                                .ConfigureAwait(false);
                            
                            var principal = await _signInManager.CreateUserPrincipalAsync(user).ConfigureAwait(false);
                            var userRoles = await _userService.GetUserRolesAsync(user);
                            var permissions = await _roleService.GetPermissionsOfRolesByNames(userRoles);
                            principal.SetClaim(Claims.Subject, user.Id.ToString())
                                .SetClaim(Claims.Email, user.Email)
                                .SetClaim(Claims.Name, user.UserName)
                                .SetClaims(O2fitIdentityConstants.PermissionToLower, permissions.ToImmutableArray())
                                .SetClaims(Claims.Role,
                                    userRoles.ToImmutableArray())
                                .SetClaim(Claims.Country, user.CountryId.ToString())
                                .SetClaim(CustomClaimsConstants.OldSystemCountryIdClaim, country.CountryId)
                                .SetClaim(CustomClaimsConstants.CountryUtcClaim, country.UtcTime)
                                .SetClaim(CustomClaimsConstants.CurrencyCodeClaim, country.CurrencyCode)
                                .SetClaim(CustomClaimsConstants.FullNameClaim, user.UserProfile.FullName)
                                .SetClaim(CustomClaimsConstants.LanguageClaim,user.Language.ToString());

                            var scopes = request.Scope?.Split(' ').ToImmutableArray();
                            principal.SetScopes(scopes);
                            principal.SetResources(await _scopeManager.ListResourcesAsync(principal.GetScopes())
                                .ToListAsync());
                            principal.SetDestinations(GetDestinations);

                            var ticket = new AuthenticationTicket(
                                principal,
                                new AuthenticationProperties(),
                                OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                            return SignIn(ticket.Principal, ticket.Properties, ticket.AuthenticationScheme);
                        }

                        if (result.IsLockedOut)
                        {
                            return BadRequest(new ApiResult("user lockout",ApiResultStatusCode.BadRequest,false));
                        }
                        if (result == SignInResult.Failed)
                        {
                             return BadRequest(new ApiResult("failed",ApiResultStatusCode.BadRequest,false));
                        }
                        
                    }

                    if (user.IsBlocked)
                        return BadRequest(new ApiResult("User is blocked", ApiResultStatusCode.BadRequest,false));
                    
                    var normalUserPrincipal = await _signInManager.CreateUserPrincipalAsync(user).ConfigureAwait(false);
                    var currentNormaUserCountry = await _mediator
                        .Send(new GetCountryByIdQuery(user.CountryId.ToString()))
                        .ConfigureAwait(false);
                    var normalUserRoles = await _userService.GetUserRolesAsync(user);
                    var normalUserPermissions = await _roleService.GetPermissionsOfRolesByNames(normalUserRoles);
                    normalUserPrincipal.SetClaim(Claims.Subject, user.Id.ToString())
                        .SetClaim(Claims.Email, user.Email)
                        .SetClaim(Claims.Name, user.UserName)
                        .SetClaims(O2fitIdentityConstants.PermissionToLower, normalUserPermissions.ToImmutableArray())
                        .SetClaims(Claims.Role,
                            normalUserRoles.ToImmutableArray())
                        .SetClaim(CustomClaimsConstants.OldSystemCountryIdClaim, currentNormaUserCountry.CountryId)
                        .SetClaim(CustomClaimsConstants.CountryUtcClaim, currentNormaUserCountry.UtcTime)
                        .SetClaim(CustomClaimsConstants.CurrencyCodeClaim, currentNormaUserCountry.CurrencyCode)
                        .SetClaim(CustomClaimsConstants.FullNameClaim, user.UserProfile.FullName)
                        .SetClaim(Claims.Country, user.CountryId.ToString())
                        .SetClaim(CustomClaimsConstants.LanguageClaim,user.Language.ToString());
                        var normalUserScopes = request.Scope?.Split(' ').ToImmutableArray();
                    normalUserPrincipal.SetScopes(normalUserScopes);
                    normalUserPrincipal.SetResources(await _scopeManager
                        .ListResourcesAsync(normalUserPrincipal.GetScopes())
                        .ToListAsync());
                    normalUserPrincipal.SetDestinations(GetDestinations);

                    var normalUserTicket = new AuthenticationTicket(
                        normalUserPrincipal,
                        new AuthenticationProperties(),
                        OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                    return SignIn(normalUserTicket.Principal, normalUserTicket.Properties,
                        normalUserTicket.AuthenticationScheme);
                }
            }

            properties = new AuthenticationProperties(new Dictionary<string, string>
            {
                [OpenIddictServerAspNetCoreConstants.Properties.Error] =
                    Errors.InvalidGrant,
                [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] =
                    "The username/password couple is invalid."
            }!);

            return Forbid(properties, OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
        }

        if (request.IsAuthorizationCodeGrantType())
        {
            // Retrieve the claims principal stored in the refresh token.
            var result =
                await HttpContext.AuthenticateAsync(OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);

            // Retrieve the user profile corresponding to the refresh token.
            if (result.Principal != null)
            {
                var user = await _userService.GetUserByIdAsync(
                    result.Principal.GetClaim(Claims.Subject) ??
                    throw new InvalidOperationException());
                // Validate the username/password parameters and ensure the account is not locked out.
                if (!string.IsNullOrEmpty(request.Password))
                {
                    var signInResult =
                        await _signInManager.CheckPasswordSignInAsync(user, request.Password, true);
                    if (!signInResult.Succeeded)
                    {
                        var properties = new AuthenticationProperties(new Dictionary<string, string>
                        {
                            [OpenIddictServerAspNetCoreConstants.Properties.Error] =
                                Errors.InvalidGrant,
                            [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] =
                                "The username/password couple is invalid."
                        }!);

                        return Forbid(properties, OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                    }
                }

                if (user == null)
                {
                    var properties = new AuthenticationProperties(new Dictionary<string, string>
                    {
                        [OpenIddictServerAspNetCoreConstants.Properties.Error] =
                            Errors.InvalidGrant,
                        [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] =
                            "The refresh token is no longer valid."
                    }!);

                    return Forbid(properties, OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                }


                // Ensure the user is still allowed to sign in.
                if (!await _signInManager.CanSignInAsync(user))
                {
                    var properties = new AuthenticationProperties(new Dictionary<string, string>
                    {
                        [OpenIddictServerAspNetCoreConstants.Properties.Error] =
                            Errors.InvalidGrant,
                        [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] =
                            "The user is no longer allowed to sign in."
                    }!);

                    return Forbid(properties, OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                }

                // var identity = new ClaimsIdentity(result.Principal.Claims,
                //     TokenValidationParameters.DefaultAuthenticationType,
                //     Claims.Name,
                //     Claims.Role);
                //
                // var userRoles = await _userService.GetUserRolesAsync(user);
                // var permissions = await _roleService.GetPermissionsOfRolesByNames(userRoles);
                //
                // // Override the user claims present in the principal in case they changed since the refresh token was issued.
                // identity.SetClaim(Claims.Subject, user.Id.ToString())
                //     .SetClaim(Claims.Email, user.Email)
                //     .SetClaim(Claims.Name, user.UserName)
                //     .SetClaims(O2fitIdentityConstants.PermissionToLower, permissions.ToImmutableArray())
                //     .SetClaims(Claims.Role,
                //         userRoles.ToImmutableArray());
                // identity.SetResources(await _scopeManager.ListResourcesAsync(identity.GetScopes()).ToListAsync());
                //
                // identity.SetDestinations(GetDestinations);
                // //identity.SetResources("api1","api2");
                //
                // return SignIn(new ClaimsPrincipal(identity),
                //     OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                var principal = await _signInManager.CreateUserPrincipalAsync(user).ConfigureAwait(false);

                var userRoles = await _userService.GetUserRolesAsync(user);
                var permissions = await _roleService.GetPermissionsOfRolesByNames(userRoles);
                principal.SetClaim(Claims.Subject, user.Id.ToString())
                    .SetClaim(Claims.Email, user.Email)
                    .SetClaim(Claims.Name, user.UserName)
                    .SetClaims(O2fitIdentityConstants.PermissionToLower, permissions.ToImmutableArray())
                    .SetClaims(Claims.Role,
                        userRoles.ToImmutableArray())
                    .SetClaim(Claims.Country, user.CountryId.ToString());
                var sss = principal.GetScopes().ToList();
                var scopes = request.Scope?.Split(' ').ToImmutableArray();
                principal.SetScopes(scopes);
                var test = await _scopeManager.ListResourcesAsync(principal.GetScopes()).ToListAsync();
                var test2 = GetDestinations;
                principal.SetResources(await _scopeManager.ListResourcesAsync(principal.GetScopes()).ToListAsync());
                principal.SetDestinations(GetDestinations);

                var ticket = new AuthenticationTicket(
                    principal,
                    new AuthenticationProperties(),
                    OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                return SignIn(ticket.Principal, ticket.Properties, ticket.AuthenticationScheme);
            }
        }

        if (request.IsRefreshTokenGrantType())
        {
            // Retrieve the claims principal stored in the refresh token.
            var result =
                await HttpContext.AuthenticateAsync(OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);

            // Retrieve the user profile corresponding to the refresh token.
            if (result.Principal != null)
            {
                // Retrieve the user profile and validate the
                // security stamp stored in the refresh token.
                var user = await _signInManager.ValidateSecurityStampAsync(result.Principal);
                if (user == null)
                {
                    var properties = new AuthenticationProperties(new Dictionary<string, string>
                    {
                        [OpenIddictServerAspNetCoreConstants.Properties.Error] =
                            Errors.InvalidGrant,
                        [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] =
                            "The refresh token is no longer valid."
                    }!);
                    return BadRequest(properties);
                }

                // Ensure the user is still allowed to sign in.
                if (!await _signInManager.CanSignInAsync(user))
                {
                    var properties = new AuthenticationProperties(new Dictionary<string, string>
                    {
                        [OpenIddictServerAspNetCoreConstants.Properties.Error] =
                            Errors.InvalidGrant,
                        [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] =
                            "The user is no longer allowed to sign in."
                    }!);

                    return BadRequest(properties);
                }

                if (user.IsBlocked)
                    return BadRequest(new ApiResult("User is blocked", ApiResultStatusCode.BadRequest,false));
                    
                var principal = await _signInManager.CreateUserPrincipalAsync(user).ConfigureAwait(false);

                var currentUserOldSystemCountryId = await _mediator
                    .Send(new GetOldSystemCountryIdByCountryIdQuery(user.CountryId.ToString()))
                    .ConfigureAwait(false);
                var currentUserCountry = await _mediator
                    .Send(new GetCountryByIdQuery(user.CountryId.ToString()));
                var userRoles = await _userService.GetUserRolesAsync(user);
                var permissions = await _roleService.GetPermissionsOfRolesByNames(userRoles);
                principal.SetClaim(Claims.Subject, user.Id.ToString())
                    .SetClaim(Claims.Email, user.Email)
                    .SetClaim(Claims.Name, user.UserName)
                    .SetClaims(O2fitIdentityConstants.PermissionToLower, permissions.ToImmutableArray())
                    .SetClaims(Claims.Role,
                        userRoles.ToImmutableArray())
                    .SetClaim(CustomClaimsConstants.OldSystemCountryIdClaim, currentUserOldSystemCountryId)
                        .SetClaim(CustomClaimsConstants.CountryUtcClaim, currentUserCountry.UtcTime)
                        .SetClaim(CustomClaimsConstants.CurrencyCodeClaim, currentUserCountry.CurrencyCode)
                        .SetClaim(CustomClaimsConstants.FullNameClaim, user.UserProfile.FullName)
                        .SetClaim(Claims.Country, user.CountryId.ToString())
                    .SetClaim(CustomClaimsConstants.LanguageClaim,user.Language.ToString());
                var scopes = request.Scope?.Split(' ').ToImmutableArray();

                principal.SetScopes(scopes);
                principal.SetResources(await _scopeManager.ListResourcesAsync(principal.GetScopes()).ToListAsync());
                principal.SetDestinations(GetDestinations);

                var ticket = new AuthenticationTicket(
                    principal,
                    new AuthenticationProperties(),
                    OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                return SignIn(ticket.Principal, ticket.Properties, ticket.AuthenticationScheme);
            }
        }

        if (request.IsClientCredentialsGrantType())
        {
            // Note: the client credentials are automatically validated by OpenIddict:
            // if client_id or client_secret are invalid, this action won't be invoked.

            var application = await _applicationManager.FindByClientIdAsync(request.ClientId);
            if (application == null)
                throw new InvalidOperationException("The application details cannot be found in the database.");

            // Create the claims-based identity that will be used by OpenIddict to generate tokens.
            var identity = new ClaimsIdentity(
                TokenValidationParameters.DefaultAuthenticationType,
                Claims.Name,
                Claims.Role);

            // Add the claims that will be persisted in the tokens (use the client_id as the subject identifier).
            identity.SetClaim(Claims.Subject, await _applicationManager.GetClientIdAsync(application));
            identity.SetClaim(Claims.Name, await _applicationManager.GetDisplayNameAsync(application));

            // Note: In the original OAuth 2.0 specification, the client credentials grant
            // doesn't return an identity token, which is an OpenID Connect concept.
            //
            // As a non-standardized extension, OpenIddict allows returning an id_token
            // to convey information about the client application when the "openid" scope
            // is granted (i.e specified when calling principal.SetScopes()). When the "openid"
            // scope is not explicitly set, no identity token is returned to the client application.

            // Set the list of scopes granted to the client application in access_token.
            identity.SetScopes(request.GetScopes());
            identity.SetDestinations(GetDestinations);
            return SignIn(new ClaimsPrincipal(identity), OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
        }

        throw new NotImplementedException("The specified grant type is not implemented.");
    }

    [AllowAnonymous]
    [HttpGet("~/connect/authorize")]
    [HttpPost("~/connect/authorize")]
    //[IgnoreAntiforgeryToken]
    public async Task<ActionResult> Authorize()
    {
        // Retrieve the OpenIddict server request from the HTTP context.
        var request = HttpContext.GetOpenIddictServerRequest() ??
                      throw new InvalidOperationException("The OpenID Connect request cannot be retrieved.");

        // Create the claims-based identity that will be used by OpenIddict to generate tokens.
        var identity = new ClaimsIdentity(
            TokenValidationParameters.DefaultAuthenticationType,
            Claims.Name,
            Claims.Role);

        // Add the claims that will be persisted in the tokens.
        if (!string.IsNullOrEmpty(request.Username))
        {
            identity.AddClaim(new Claim(Claims.Username, request.Username));


            // Allow all claims to be added in the access tokens.
            //  identity.SetDestinations(claim => new[] {Destinations.AccessToken});

            if (!string.IsNullOrEmpty(request.Username) && !string.IsNullOrEmpty(request.Password))
            {
                var user = await _userService.GetUserByUsernameAsync(request.Username).ConfigureAwait(false);
                if (user == null)
                    return Forbid(
                        authenticationSchemes: new[] { OpenIddictServerAspNetCoreDefaults.AuthenticationScheme },
                        properties: new AuthenticationProperties(new Dictionary<string, string>
                        {
                            [OpenIddictServerAspNetCoreConstants.Properties.Error] = Errors.InvalidRequest,
                            [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] = "User not found"
                        }!));

                if (user.IsBlocked)
                    return BadRequest(new ApiResult("user is block", ApiResultStatusCode.BadRequest,false));

                var result = await _signInManager.PasswordSignInAsync(user, request.Password, false, true)
                    .ConfigureAwait(false);
                if (result.Succeeded)
                {
                    var userRoles = await _userService.GetUserRolesAsync(user);
                    var permissions = await _roleService.GetPermissionsOfRolesByNames(userRoles);

                    // Override the user claims present in the principal in case they changed since the refresh token was issued.
                    identity.SetClaim(Claims.Subject, user.Id.ToString())
                        .SetClaim(Claims.Email, user.Email)
                        .SetClaim(Claims.Name, user.UserName)
                        .SetClaims(O2fitIdentityConstants.PermissionToLower, permissions.ToImmutableArray())
                        .SetClaims(Claims.Role,
                            userRoles.ToImmutableArray())
                        .SetClaim(Claims.Country, user.CountryId.ToString());
                    identity.SetResources(await _scopeManager.ListResourcesAsync(identity.GetScopes()).ToListAsync());

                    // Retrieve the application details from the database.
                    var application = await _applicationManager.FindByClientIdAsync(request.ClientId) ??
                                      throw new InvalidOperationException(
                                          "Details concerning the calling client application cannot be found.");

                    // Retrieve the permanent authorizations associated with the user and the calling client application.
                    var authorizations = await _authorizationManager.FindAsync(
                        subject: await _userManager.GetUserIdAsync(user),
                        client: (await _applicationManager.GetIdAsync(application))!,
                        status: Statuses.Valid,
                        type: AuthorizationTypes.Permanent,
                        scopes: request.GetScopes()).ToListAsync();

                    // Automatically create a permanent authorization to avoid requiring explicit consent
                    // for future authorization or token requests containing the same scopes.
                    var authorization = authorizations.LastOrDefault();
                    authorization ??= await _authorizationManager.CreateAsync(
                        identity: identity,
                        subject: await _userManager.GetUserIdAsync(user),
                        client: (await _applicationManager.GetIdAsync(application))!,
                        type: AuthorizationTypes.Permanent,
                        scopes: identity.GetScopes());

                    identity.SetAuthorizationId(await _authorizationManager.GetIdAsync(authorization));
                    identity.SetDestinations(GetDestinations);
                    return SignIn(new ClaimsPrincipal(identity),
                        OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                }

                if (result.IsLockedOut)
                    return BadRequest();

                if (result.IsNotAllowed)
                    return BadRequest(new ApiResult("User not allowed", ApiResultStatusCode.BadRequest,false));
                if (!result.Succeeded)
                {
                    return BadRequest(new ApiResult("Failed to authorize", ApiResultStatusCode.BadRequest,false));
                }
            }

            if (!string.IsNullOrEmpty(request.Username))
            {
                var user = await _userService.GetUserByUsernameAsync(request.Username).ConfigureAwait(false);
                if (user == null)
                    return Forbid(
                        authenticationSchemes: new[] { OpenIddictServerAspNetCoreDefaults.AuthenticationScheme },
                        properties: new AuthenticationProperties(new Dictionary<string, string>
                        {
                            [OpenIddictServerAspNetCoreConstants.Properties.Error] = Errors.InvalidRequest,
                            [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] = "User not found"
                        }!));

                var result = await _signInManager.CanSignInAsync(user).ConfigureAwait(false);
                if (result)
                {
                    var userRoles = await _userService.GetUserRolesAsync(user);
                    var permissions = await _roleService.GetPermissionsOfRolesByNames(userRoles);

                    // Override the user claims present in the principal in case they changed since the refresh token was issued.
                    identity.SetClaim(Claims.Subject, user.Id.ToString())
                        .SetClaim(Claims.Email, user.Email)
                        .SetClaim(Claims.Name, user.UserName)
                        .SetClaims(O2fitIdentityConstants.PermissionToLower, permissions.ToImmutableArray())
                        .SetClaims(Claims.Role,
                            userRoles.ToImmutableArray());

                    identity.SetDestinations(GetDestinations);

                    return SignIn(new ClaimsPrincipal(identity),
                        OpenIddictServerAspNetCoreDefaults.AuthenticationScheme);
                }

                return Forbid(
                    authenticationSchemes: new[] { OpenIddictServerAspNetCoreDefaults.AuthenticationScheme },
                    properties: new AuthenticationProperties(new Dictionary<string, string>
                    {
                        [OpenIddictServerAspNetCoreConstants.Properties.Error] = Errors.InvalidRequest,
                        [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] =
                            "this user can not sign in"
                    }!));
            }
        }

        return Forbid(
            authenticationSchemes: new[] { OpenIddictServerAspNetCoreDefaults.AuthenticationScheme },
            properties: new AuthenticationProperties(new Dictionary<string, string>
            {
                [OpenIddictServerAspNetCoreConstants.Properties.Error] = Errors.InvalidRequest,
                [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] = "invalid parameter"
            }!));
    }

    private static IEnumerable<string> GetDestinations(Claim claim)
    {
        // Note: by default, claims are NOT automatically included in the access and identity tokens.
        // To allow OpenIddict to serialize them, you must attach them a destination, that specifies
        // whether they should be included in access tokens, in identity tokens or in both.

        switch (claim.Type)
        {
            case Claims.Name:
                yield return Destinations.AccessToken;

                if (claim.Subject!.HasScope(Permissions.Scopes.Profile))
                {
                    yield return Destinations.IdentityToken;
                    yield return Claims.Country;
                    yield return Claims.Name;
                    yield return Claims.Subject;
                }

                yield break;

            case Claims.Email:
                yield return Destinations.AccessToken;

                if (claim.Subject!.HasScope(Permissions.Scopes.Email))
                    yield return Destinations.IdentityToken;

                yield break;

            case Claims.Role:
                yield return Destinations.AccessToken;

                if (claim.Subject!.HasScope(Permissions.Scopes.Roles))
                    yield return Destinations.IdentityToken;

                yield break;

            // Never include the security stamp in the access and identity tokens, as it's a secret value.
            case "AspNet.Identity.SecurityStamp": yield break;

            default:
                yield return Destinations.AccessToken;
                yield break;
        }
    }
}